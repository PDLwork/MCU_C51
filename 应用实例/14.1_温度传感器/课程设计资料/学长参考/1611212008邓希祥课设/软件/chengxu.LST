C51 COMPILER V9.01   CHENGXU                                                               01/06/2020 23:36:35 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE CHENGXU
OBJECT MODULE PLACED IN chengxu.OBJ
COMPILER INVOKED BY: E:\keil\anzhuang\C51\BIN\C51.EXE chengxu.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h> 
   2          #include <DS18B20_1.h>
   3          #include <DS18B20_2.h> 
   4          #include <math.h>         
   5          
   6          #define uchar unsigned char       
   7          #define uint  unsigned  int      
   8          sbit BUTON1=P1^0;
   9          sbit BUTON2=P1^1;
  10          sbit BUTON3=P1^2;
  11          sbit BUTON4=P1^3;
  12          sbit BUTON5=P1^4;
  13          sbit BUTON6=P1^5;
  14          sbit w1=P2^0;
  15          sbit w2=P2^1;
  16          sbit w3=P2^2;
  17          sbit w4=P2^3;
  18          sbit w5=P2^4;
  19          sbit w6=P2^5;
  20          sbit w7=P2^6;
  21          sbit w8=P2^7;
  22          sbit bz=P1^6;
  23          #define all_off {P2=0XFF;}
  24          
  25          bit flag_disp;
  26          uchar count,yuzhi1=15,yuzhi2=30;                                
  27          int temperature_1,temperature_2,temperature;         //存放温度值
  28          code uchar shuma[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90}; //显示段码 共阳数码管
  29          //延时函数
  30          void delay(uint num)
  31          {
  32   1              while( --num );
  33   1      }
  34          void disp()     //数码管显示函数 
  35          {
  36   1              if(flag_disp==0) //显示第一路
  37   1              {
  38   2                      if(flag_fu1==1)  //负温度
  39   2                      {all_off;P0=0xBF;w1=0;delay(150);}
  40   2                      else
  41   2                      {all_off;P0=0xFF;w1=0;delay(150);}
  42   2              }
  43   1              else //显示第二路
  44   1              {
  45   2                      if(flag_fu2==1)  //负温度
  46   2                      {all_off;P0=0xBF;w1=0;delay(150);}
  47   2                      else
  48   2                      {all_off;P0=0xFF;w1=0;delay(150);}
  49   2              }
  50   1              all_off;P0=shuma[temperature/1000];w2=0;delay(150); //带小数点位
  51   1              all_off;P0=shuma[temperature/100%10]&0x7F;w3=0;delay(150);//显示温度
  52   1              all_off;P0=shuma[temperature/10%10];w4=0;delay(150);
  53   1      
  54   1              all_off;P0=shuma[yuzhi1/10];w5=0;delay(150);//显示上限
  55   1              all_off;P0=shuma[yuzhi1%10];w6=0;delay(150);
C51 COMPILER V9.01   CHENGXU                                                               01/06/2020 23:36:35 PAGE 2   

  56   1      
  57   1              all_off;P0=shuma[yuzhi2/10];w7=0;delay(150);//显示下限
  58   1              all_off;P0=shuma[yuzhi2%10];w8=0;delay(150);
  59   1      
  60   1      }
  61          void BUTONscan()           //按键扫描函数
  62          {
  63   1              if(!BUTON1)        //检测按下
  64   1              {
  65   2                      delay(10); //延时消抖动                     
  66   2                      if(!BUTON1)  //
  67   2                      {
  68   3                              if(yuzhi1<99)yuzhi1++;
  69   3                              while(!BUTON1){;}//检测松手
  70   3                      }
  71   2              }
  72   1              if(!BUTON2)        //检测按下
  73   1              {
  74   2                      delay(10); //延时消抖动
  75   2                      if(!BUTON2)  //
  76   2                      {
  77   3                              if(yuzhi1>1)yuzhi1--;
  78   3                              while(!BUTON2){;}//检测松手
  79   3                      }
  80   2              }
  81   1              if(!BUTON3)        //检测按下
  82   1              {
  83   2                      delay(10); //延时消抖动
  84   2                      if(!BUTON3)  //
  85   2                      {
  86   3                              flag_disp=0;
  87   3                              while(!BUTON3){;}//检测松手
  88   3                      }
  89   2              }
  90   1              if(!BUTON4)        //检测按下
  91   1              {
  92   2                      delay(10); //延时消抖动
  93   2                      if(!BUTON4)  //
  94   2                      {
  95   3                              flag_disp=1;
  96   3                              while(!BUTON4){;}//检测松手
  97   3                      }
  98   2              }
  99   1              if(!BUTON5)        //检测按下
 100   1              {
 101   2                      delay(10); //延时消抖动
 102   2                      if(!BUTON5)  //
 103   2                      {
 104   3                              if(yuzhi2<99)yuzhi2++;
 105   3                              while(!BUTON5){;}//检测松手
 106   3                      }
 107   2              }
 108   1              if(!BUTON6)        //检测按下
 109   1              {
 110   2                      delay(10); //延时消抖动
 111   2                      if(!BUTON6)  //
 112   2                      {
 113   3                              if(yuzhi2>1)yuzhi2--;
 114   3                              while(!BUTON6){;}//检测松手
 115   3                      }
 116   2              }
 117   1      }
C51 COMPILER V9.01   CHENGXU                                                               01/06/2020 23:36:35 PAGE 3   

 118          void main()
 119          {
 120   1              TMOD |= 0x01;   //初始化定时器0              
 121   1              TL0 = 0x00;             //设置定时初值
 122   1              TH0 = 0xee;             //设置定时初值5MS
 123   1              EA=1;                      
 124   1              ET0=1;                 
 125   1              TR0=0;  
 126   1      
 127   1              while(1)                
 128   1              {
 129   2                      BUTONscan();    //按键扫描函数
 130   2                      temperature_1=ReadTemperature_1();       //读温度1
 131   2                      temperature_2=ReadTemperature_2();       //读温度2
 132   2                              
 133   2                      temperature_1 = abs(temperature_1);//取绝对值
 134   2                      temperature_1=temperature_1%10000;//温度整数和2位小数(现在是十进制数)
 135   2                      temperature_2 = abs(temperature_2);//取绝对值
 136   2                      temperature_2=temperature_2%10000;//温度整数和2位小数(现在是十进制数)
 137   2                      if(flag_disp==0)
 138   2                      {temperature=temperature_1;}
 139   2                      else
 140   2                      {temperature=temperature_2;}
 141   2                      if(flag_fu1==1 || flag_fu2==1 || temperature_1<yuzhi1*100 || temperature_1>yuzhi2*100 || temperature_2<y
             -uzhi1*100 || temperature_2>yuzhi2*100)        
 142   2                              bz=0;
 143   2                      else
 144   2                              bz=1;
 145   2                      disp();                 //数码管显示
 146   2              }
 147   1      }
 148          void Tim() interrupt 1 
 149          {
 150   1              TL0 = 0x00;             //设置定时初值
 151   1              TH0 = 0xee;             //设置定时初值
 152   1      
 153   1              count++;
 154   1              switch(count)  //数码管动态显示
 155   1              {
 156   2                      case 1:all_off;P0=shuma[temperature/1000];w1=0;
 157   2                      break;
 158   2                      case 2:all_off;P0=shuma[temperature/100%10]&0x7F;w2=0;
 159   2                      break;
 160   2                      case 3:all_off;P0=shuma[temperature/10%10];w3=0;
 161   2                      break;
 162   2                      case 4:all_off;P0=shuma[temperature%10];w4=0;
 163   2                      break;
 164   2                      case 5:all_off;P0=shuma[56/10];w5=0;
 165   2                      break;
 166   2                      case 6:all_off;P0=shuma[56%10];w6=0;
 167   2                      break;
 168   2                      case 7:all_off;P0=shuma[15/10];w7=0;
 169   2                      break;
 170   2                      case 8:all_off;P0=shuma[15%10];w8=0;count=0;
 171   2                      break;
 172   2                      default:break;
 173   2              }
 174   1      }       


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    882    ----
C51 COMPILER V9.01   CHENGXU                                                               01/06/2020 23:36:35 PAGE 4   

   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
